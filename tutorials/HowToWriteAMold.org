* How to write a mold
:PROPERTIES:
:CREATED:  [2021-10-04 Mon 22:15]
:ID:       6c3d30f3-03ea-42e9-b962-f3fd136ed1e0
:END:

This tutorial should teach you the basics of writing molds.

** The basics of a mold
:PROPERTIES:
:CREATED:  [2021-10-04 Mon 22:15]
:ID:       94d71322-fec6-4e36-96dc-bd8230069b56
:END:

A mold is a micro view telling a micro story. For example,
“given a CSV buffer, then I will show its columns.” Micro-stories have
micro-meaning. The more you compose, the bigger and more meaningful the
story.

You define a mold as a =plist=. A mold requires three keys:

- =:key= :: the identifier of the mold.
  (The naming conventions are still to develop, I will update this later.)
- =:given= :: the pre-condition for the mold to be usable. This is typically a function.
- =:then= :: the post-condition of the mold. This is also typically a function.

The other keys are cool, but for another tutorial!

Now let's write a hello-world mold. We will do in two steps
to learn how to write very small molds for maximum composition (which
is the power of moldable-emacs).

** The hello mold
:PROPERTIES:
:CREATED:  [2021-10-04 Mon 22:16]
:ID:       3ba298fe-2312-48af-b2eb-d0114fd37ecc
:END:

The first bit of a hello-world mold is something that says hello.

Let's design! We want our hello mold to only greet files. So, our
pre-condition is that a buffer must have a file. The mold should
display a new buffer with "hello <filename>".

Let's write it!

#+begin_src elisp
(me-register-mold
 :key "To Hello" ;; the :key clause
 :given (:fn (and (buffer-file-name))) ;; the :given clause
 :then (:fn  ;; the :then clause
        (let* ((file buffer-file-name)) ;; the scope here is in the original buffer you called the mold from
          (with-current-buffer buffername ;; `buffername' is available by default
            (erase-buffer)
            (insert (format "Hello %s!" file))
            (setq-local self file)))) ;; always set the `self' variable!
 :docs "You can let the mold say hello to a file")
#+end_src

As you can see, we used all the keys we learned about: =:key=, =:given=, and
=:then=. We even used an extra one, =:docs,= which describes in more details what the mold does.

Note that you need to use =:fn= to provide =:given= and =:then= a
function (body). Also make sure to set =self= to a useful value.

Now, evaluate the Org Mode block above (=C-c C-c= on the block) – you may need to
activate elisp with =org-babel= by setting the =org-babel-load-languages= option
appropriately. If you are following this from the tutorial mold, then you will
see you cannot use your mold.

Instead jump to a file and run it! You should see a new buffer pop up
starting with “Hello” and displaying the full path to the current file.

A few steps you can take from there:

1. Allow the mold to work with buffers as well (i.e., change
   buffer-file-name -> buffer-name), and test it does indeed work for buffers
2. in the resulting buffer use =M-:= and type "self" and see what happens
3. change =(setq-local self file)= to =(setq-local self '(:lol
   "lol"))= and see what happens if you repeat the step above
4. instead of using =M-:=, invoke =M-x me-mold=, type "Query", select
   the mold and finally type "self".

** Composition
:PROPERTIES:
:CREATED:  [2021-10-04 Mon 22:16]
:END:

As mentioned above, the secret power of molds is composition! When you
produce a view of something with a mold, that view opens new molding
options. For example, say you take some text and extract a table
of data from it: now all the molds that operate on tables are available
for further transformation (table->json, table->graph-cli, etc.).

I will show next another mold that you can use after our “To Hello”
one and quickly produce a mold that composes the two.

*** Refresher: The world mold
:PROPERTIES:
:CREATED:  [2021-10-04 Mon 22:16]
:ID:       3ce6612d-40c4-4f22-bcbc-b86c0d5012e3
:END:

Let's complete the message produced by the "To Hello" mold above with
"world <filename>!". So if we are in a file =text.txt=, applying first
"To Hello" and then "To World" will result in a buffer containing
"Hello world test.txt!".

The mold is pretty easy to write if we rely on =self=:

#+begin_src elisp
(me-register-mold
 :key "To World" ;; the :key clause
 :given (:fn (and  ;; the :given clause
                  (ignore-errors (equal "To Hello" (plist-get mold-data :old-mold)))))  ;; mold-data contains the data about the previous mold run
 :then (:fn  ;; the :then clause
        (let* ((file self)) ;; the scope here is in the original buffer you called the mold from, so the "To Hello" buffer!
          (with-current-buffer buffername ;; `buffername' is available by default
            (erase-buffer)
            (insert (format "Hello world %s!" file))
            (setq-local self file)))) ;; always set the `self' variable!
 :docs "You can let the mold say hello world to a file")
#+end_src

Note that the =:given= precondition uses =mold-data=. Any mold that
you run sets this variable to give context about the previous run.
Here we use the =:old-mold= attribute to find out we used "To Hello"
to produce this view. We want "To World" to work only after "To
Hello". I added =ignore-errors= to handle the cases where we didn't
run a mold before.

We then use =self= to get the value of the original file, because we
rely on "To Hello" setting it.

After evaluating the Elisp code above, try to run "To Hello" on a file
buffer and immediately after run "To World". If you do so:
congratulations! You have just composed molds!

*** The hello world mold
:PROPERTIES:
:CREATED:  [2021-10-04 Mon 22:16]
:ID:       0293b96b-7e1a-4d8b-9b07-db5a95986334
:END:

Let's finish with a trick. When you find that you keep repeating a combination
of molds, you may have to establish a composition. This way you can
call a single mold to run multiple molds in a sequence.

The code is simple:

#+begin_src elisp
(me-register-mold-by-key
 "To Hello World"
 (me-mold-compose
  "To Hello"
  "To World"
  '((:docs "You can let the mold say hello world to a file"))))
#+end_src

You are registering a new mold. Note that you can add properties as
=:docs= and =:examples= in the third parameter of =me-mold-compose=.

If you evaluate the above, you can call the new mold directly. This will
generate two buffers because it is just doing the composition for you.

You can compose more than one mold! Check out the code of
"FirstOrgTableToLineChart" to see how that looks like. (Final
challenge to you: to view the code, run =M-x me-mold= in this buffer,
select "WhatMoldsCanIUse?" and open its code via the link)
